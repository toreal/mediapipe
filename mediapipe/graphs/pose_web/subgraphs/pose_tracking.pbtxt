type: "PoseTrackingSubgraph"

input_stream: "IMAGE:input_video"
output_stream: "LANDMARKS:pose_landmarks"
output_stream: "NORM_RECT:pose_rect"
output_stream: "DETECTIONS:palm_detections"

# Caches a pose-presence decision fed back from PoseLandmarkSubgraph, and upon
# the arrival of the next input image sends out the cached decision with the
# timestamp replaced by that of the input image, essentially generating a packet
# that carries the previous pose-presence decision. Note that upon the arrival
# of the very first input image, an empty packet is sent out to jump start the
# feedback loop.
node {
  calculator: "PreviousLoopbackCalculator"
  input_stream: "MAIN:input_video"
  input_stream: "LOOP:pose_presence"
  input_stream_info: {
    tag_index: "LOOP"
    back_edge: true
  }
  output_stream: "PREV_LOOP:prev_pose_presence"
}

# Drops the incoming image if PoseLandmarkSubgraph was able to identify pose
# presence in the previous image. Otherwise, passes the incoming image through
# to trigger a new round of pose detection in PoseDetectionSubgraph.
node {
  calculator: "GateCalculator"
  input_stream: "input_video"
  input_stream: "DISALLOW:prev_pose_presence"
  output_stream: "pose_detection_input_video"

  node_options: {
    [type.googleapis.com/mediapipe.GateCalculatorOptions] {
      empty_packets_as_allow: true
    }
  }
}

# Subgraph that detections poses (see pose_detection_gpu.pbtxt).
node {
  calculator: "PoseDetectionSubgraph"
  input_stream: "pose_detection_input_video"
  output_stream: "DETECTIONS:palm_detections"
  output_stream: "NORM_RECT:pose_rect_from_palm_detections"
}

# Subgraph that localizes pose landmarks (see pose_landmark_gpu.pbtxt).
node {
  calculator: "PoseLandmarkSubgraph"
  input_stream: "IMAGE:input_video"
  input_stream: "NORM_RECT:pose_rect"
  output_stream: "LANDMARKS:pose_landmarks"
  output_stream: "NORM_RECT:pose_rect_from_landmarks"
  output_stream: "PRESENCE:pose_presence"
}

# Caches a pose rectangle fed back from PoseLandmarkSubgraph, and upon the
# arrival of the next input image sends out the cached rectangle with the
# timestamp replaced by that of the input image, essentially generating a packet
# that carries the previous pose rectangle. Note that upon the arrival of the
# very first input image, an empty packet is sent out to jump start the
# feedback loop.
node {
  calculator: "PreviousLoopbackCalculator"
  input_stream: "MAIN:input_video"
  input_stream: "LOOP:pose_rect_from_landmarks"
  input_stream_info: {
    tag_index: "LOOP"
    back_edge: true
  }
  output_stream: "PREV_LOOP:prev_pose_rect_from_landmarks"
}

# Merges a stream of pose rectangles generated by PoseDetectionSubgraph and that
# generated by PoseLandmarkSubgraph into a single output stream by selecting
# between one of the two streams. The former is selected if the incoming packet
# is not empty, i.e., pose detection is performed on the current image by
# PoseDetectionSubgraph (because PoseLandmarkSubgraph could not identify pose
# presence in the previous image). Otherwise, the latter is selected, which is
# never empty because PoseLandmarkSubgraphs processes all images (that went
# through FlowLimiterCaculator).
node {
  calculator: "MergeCalculator"
  input_stream: "pose_rect_from_palm_detections"
  input_stream: "prev_pose_rect_from_landmarks"
  output_stream: "pose_rect"
}
